package com.example.renteco_v1.apiimport android.content.Contextimport android.util.Logimport com.example.renteco_v1.MyApplicationimport com.example.renteco_v1.user_access.login.data.remote.Userimport com.google.gson.GsonBuilderimport okhttp3.OkHttpClientimport retrofit2.Retrofitimport retrofit2.converter.gson.GsonConverterFactoryimport java.io.FileInputStreamimport java.security.KeyStoreimport java.security.cert.CertificateFactoryimport java.security.cert.X509Certificateimport javax.net.ssl.HostnameVerifierimport javax.net.ssl.KeyManagerFactoryimport javax.net.ssl.SSLContextimport javax.net.ssl.TrustManagerFactoryimport javax.net.ssl.X509TrustManagerimport kotlin.properties.Delegatesobject Api {   //private val url = "licenta.renteco.info:443"    private val url = "34******:443"   // private val url = "192.168.0.191:443"    private val httpUrl = "https://$url/"    private var gson = GsonBuilder().create()    val tokenInterceptor = TokenInterceptor()    var currentEmail = "defaultEmail"    var currentUser: User by Delegates.observable(User()) { _, oldValue, newValue ->        Log.d("Api", "currentUser changed from $oldValue to $newValue")    }    var startTime: String = "2021-06-01T00:00:00.000Z"    var alreadyRunning: Boolean = true    lateinit var sslContext: SSLContext    lateinit var trustManager: X509TrustManager    lateinit var okHttpClient: OkHttpClient    lateinit var retrofit: Retrofit    //arduino    val secretKey = "my_secret_key"    fun loadKeyStore(context: Context){        val keystorePath = context.assets.open("keystore.p12")// Specifică calea către fișierul cu keystore.p12        val keystorePassword = "cactus" // Specifică parola pentru keystore.p12        val keystore = KeyStore.getInstance("PKCS12")//        keystore.load(FileInputStream(keystorePath), keystorePassword.toCharArray())        keystore.load(keystorePath, keystorePassword.toCharArray())        val keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())        keyManagerFactory.init(keystore, keystorePassword.toCharArray())        val trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())        trustManagerFactory.init(keystore)        val trustManagers = trustManagerFactory.trustManagers        check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {            "Unexpected default trust managers: ${trustManagers.contentToString()}"        }        trustManager = trustManagers[0] as X509TrustManager        this.sslContext = SSLContext.getInstance("TLS")        sslContext.init(keyManagerFactory.keyManagers, trustManagerFactory.trustManagers, null)    }    fun createRetrofit() {        val hostnameVerifier = HostnameVerifier { _, _ -> true }         okHttpClient = OkHttpClient.Builder()           //  .apply { this.addInterceptor(tokenInterceptor) }asta l am folosit la html             .sslSocketFactory(sslContext.socketFactory, trustManager) //asta e pentru https             . hostnameVerifier(hostnameVerifier)//asta pentru a evita man in the middle, l am dezactivat ca nu am setat numele gazdei(serverului - ip ul) in certificat            .build()         retrofit = Retrofit.Builder()            .baseUrl(httpUrl)            .client(okHttpClient)            .addConverterFactory(GsonConverterFactory.create(gson))            .build()    }}